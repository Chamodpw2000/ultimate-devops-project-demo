Detailed breakdown of a typical Kubernetes deployment manifest like deploy.yaml:

apiVersion: Specifies the Kubernetes API version (e.g., apps/v1).

In Kubernetes, the "apiVersion" field in a manifest file specifies which version of the Kubernetes API should be used to process and manage the resource described in the file.

Each resource type (like Deployment, Service, Pod) may have different API versions, such as:

v1 (for core resources like Pod, Service)
apps/v1 (for resources like Deployment, StatefulSet)
batch/v1 (for resources like Job, CronJob)
The apiVersion ensures compatibility and determines which features and schema are available for that 
resource. Using the correct apiVersion is important for Kubernetes to understand and correctly 
handle the resource.

kind: Indicates the resource type, usually Deployment.

In Kubernetes manifests, the "kind" field specifies the type of resource you want to create or manage.

Examples of "kind" values include:

Pod: A single container or group of containers.
Service: Exposes a set of pods as a network service.
Deployment: Manages a set of replicated pods, enabling updates and scaling.
ConfigMap, Secret, StatefulSet, etc.
The "kind" tells Kubernetes what action to take and how to interpret the rest of the manifest. 
Each kind has its own structure and purpose within the cluster.

metadata: Contains identifying information such as name, namespace, and labels for the deployment.

Labels in Kubernetes metadata are used to organize, identify, and select resources. 
They are key-value pairs attached to objects like pods, deployments, and services.

Reasons for using labels:

Enable grouping and filtering of resources (e.g., select all pods with app=accounting).
Facilitate service discovery and load balancing.
Support deployment strategies, scaling, and rolling updates.
Help manage environments (e.g., env=prod, env=dev).
Labels make it easy to manage and automate operations in large clusters by 
allowing flexible queries and resource selection.

A namespace in Kubernetes is used to divide cluster resources between multiple users, teams, or environments. It provides a way to organize and isolate resources such as pods, services, and deployments.

Reasons for using namespaces:

Separation of environments (e.g., development, testing, production).
Resource isolation for security and management.
Avoiding naming conflicts between resources.
Delegating access and permissions to different teams.
Namespaces help manage large clusters by grouping related resources and controlling access.

spec:

replicas: Number of pod instances to run for the service.
selector: Defines how Kubernetes matches pods to this deployment using labels.
template:
metadata: Labels for the pods created by this deployment.
spec:
containers: List of containers to run in each pod.
name: Name of the container.
image: Docker image for the accounting service.
ports: Exposed container ports.
env: Environment variables for configuration.
resources: CPU and memory limits/requests.
livenessProbe/readinessProbe: Health checks to ensure the pod is running and ready.

